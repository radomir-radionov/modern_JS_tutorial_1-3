///  Modern JavaScript tutorial  ///

// ВВЕДЕНИЕ

// 1.1 Введение в JavaScript

// Что такое JavaScript?

// Изначально JavaScript был создан, чтобы «сделать веб-страницы живыми».
// Программы на этом языке называются скриптами. Они могут встраиваться в HTML и выполняться автоматически при загрузке веб-страницы.
// Скрипты распространяются и выполняются, как простой текст. Им не нужна специальная подготовка или компиляция для запуска.

// Как работают движки?
// Движки сложны. Но основы понять легко.

// Движок (встроенный, если это браузер) читает («парсит») текст скрипта.
// Затем он преобразует («компилирует») скрипт в машинный язык.
// После этого машинный код запускается и работает достаточно быстро.

// Например, в браузере JavaScript может:

// Добавлять новый HTML-код на страницу, изменять существующее содержимое, модифицировать стили.
// Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.
// Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии AJAX и COMET).
// Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.
// Запоминать данные на стороне клиента («local storage»).

// сильные стороны JavaScript:

// Полная интеграция с HTML/CSS.
// Простые вещи делаются просто.
// Поддерживается всеми основными браузерами и включён по умолчанию.

// 1.2 Справочники и спецификации

// Спецификация ECMA-262
// https://www.ecma-international.org/publications/standards/Ecma-262.htm

// Чтобы почитать о самых последних возможностях, включая те, которые «почти в стандарте»
// (так называемые «stage 3 proposals»), посетите https://github.com/tc39/proposals.

// Справочники

// MDN (Mozilla) JavaScript Reference
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference

// MSDN
// https://docs.microsoft.com/ru-ru/

// Таблицы совместимости

// Посмотреть, какие возможности поддерживаются в разных браузерах и других движках, можно в следующих источниках:

// http://caniuse.com – таблицы с информацией о поддержке по каждой возможности языка. Например, чтобы узнать, какие движки поддерживают современные криптографические функции, посетите: http://caniuse.com/#feat=cryptography.
// https://kangax.github.io/compat-table – таблица с возможностями языка и движками, которые их поддерживают и не поддерживают.

// 1.3 Редакторы кода

// Есть два основных типа редакторов: IDE и «лёгкие» редакторы. Многие используют по одному инструменту каждого типа.

// IDE

// Термином IDE (Integrated Development Environment, «интегрированная среда разработки») называют мощные редакторы с
//  множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а нечто большее.

//  IDE загружает проект (который может состоять из множества файлов), позволяет переключаться между файлами, предлагает автодополнение по коду всего проекта (а не только открытого файла), также она интегрирована с системой контроля версий (например, такой как git), средой для тестирования и другими инструментами на уровне всего проекта.

// Если вы ещё не выбрали себе IDE, присмотритесь к этим:

// Visual Studio Code (бесплатно).
// WebStorm (платно).

// «Лёгкие» редакторы

// «Лёгкие» редакторы менее мощные, чем IDE, но они отличаются скоростью, удобным интерфейсом и простотой.

// Главное отличие между «лёгким» редактором и IDE состоит в том, что IDE работает на уровне целого проекта, поэтому
// она загружает больше данных при запуске, анализирует структуру проекта, если это необходимо, и так далее. Если вы
// работаете только с одним файлом, то гораздо быстрее открыть его в «лёгком» редакторе.

// Следующие варианты заслуживают вашего внимания:

// Atom (кроссплатформенный, бесплатный).
// Sublime Text (кроссплатформенный, условно-бесплатный).
// Notepad++ (Windows, бесплатный).
// Vim и Emacs тоже хороши, если знать, как ими пользоваться.

// 1.4 Консоль разработчика(F12)

// Под сообщением об ошибке находится синий символ >. Он обозначает командную строку, в ней мы можем редактировать
// и запускать JavaScript-команды. Для их запуска нажмите Enter.

// Многострочный ввод
// Обычно при нажатии Enter введённая строка кода сразу выполняется.

// Чтобы перенести строку, нажмите Shift+Enter. Так можно вводить более длинный JS-код.

// Итого

// Инструменты разработчика позволяют нам смотреть ошибки, выполнять команды, проверять значение переменных и ещё много всего полезного.
// В большинстве браузеров, работающих под Windows, инструменты разработчика можно открыть, нажав F12.
// В Chrome для Mac используйте комбинацию Cmd+Opt+J, Safari: Cmd+Opt+C (необходимо предварительное включение «Меню разработчика»).

// ОСНОВЫ JavaScript

// 2.1 Привет, мир!

// Тег «script»
// Программы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега <script>.

// <script>
// alert( 'Привет, мир!' );
// </script>

// Внешние скрипты

// Файл скрипта можно подключить к HTML с помощью атрибута src:

// <script src="/path/to/script.js"></script>

// Здесь /path/to/script.js – это абсолютный путь до скрипта от корня сайта. Также можно указать
// относительный путь от текущей страницы. Например, src="script.js" будет означать, что файл "script.js" находится в текущей папке.

// Можно указать и полный URL-адрес. Например:

// <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>

// Для подключения нескольких скриптов используйте несколько тегов:

// <script src="/js/script1.js"></script>
// <script src="/js/script2.js"></script>

// На заметку:

// Как правило, только простейшие скрипты помещаются в HTML. Более сложные выделяются в отдельные файлы.
// Польза от отдельных файлов в том, что браузер загрузит скрипт отдельно и сможет хранить его в кеше.
// Другие страницы, которые подключают тот же скрипт, смогут брать его из кеша вместо повторной загрузки
// из сети. И таким образом файл будет загружаться с сервера только один раз.
// Это сокращает расход трафика и ускоряет загрузку страниц.

// Если атрибут src установлен, содержимое тега script будет игнорироваться.

// <script src="file.js">
//   alert(1); // содержимое игнорируется, так как есть атрибут src
// </script>

// <script src="file.js"></script>
// <script>
//   alert(1);
// </script>

// Итого
// Для добавления кода JavaScript на страницу используется тег <script>
// Атрибуты type и language необязательны.
// Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>.

// 2.2 Структура кода

// Инструкции
// Инструкции – это синтаксические конструкции и команды, которые выполняют действия.

// alert('Привет, мир!')

// Точка с запятой

// alert('Привет')
// alert('Мир')
// В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.

// В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!

// В некоторых ситуациях новая строка всё же не означает точку с запятой. Например:

// alert(3 +
// 1
// + 2);

// Комментарии

// Однострочные комментарии начинаются с двойной косой черты //.
// Часть строки после // считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.

// Многострочные комментарии начинаются косой чертой со звёздочкой /* и заканчиваются звёздочкой с косой чертой */.

// Используйте горячие клавиши!
// В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+
// / для однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев
// (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.

// Вложенные комментарии не поддерживаются!

// 2.4 Переменные

// JavaScript-приложению обычно нужно работать с информацией. Например:

// Интернет-магазин – информация может включать продаваемые товары и корзину покупок.
// Чат – информация может включать пользователей, сообщения и многое другое.
// Переменные используются для хранения этой информации.

// Переменная – это «именованное хранилище» для данных.

// Приведённая ниже инструкция создаёт (другими словами: объявляет или определяет) переменную с именем «message»:

// let message;

// оператор присваивания =

// Имена переменных
// В JavaScript есть два ограничения, касающиеся имён переменных:

// Имя переменной должно содержать только буквы, цифры или символы $ и _.
// Первый символ не должен быть цифрой.

// Итого
// Мы можем объявить переменные для хранения данных с помощью ключевых слов var, let или const.

// let – это современный способ объявления.
// var – это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое слово "var" на случай, если это всё-таки вам понадобится.
// const – похоже на let, но значение переменной не может изменяться.
// Переменные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.

// Объявите две переменные: admin и name.
// Запишите строку "Джон" в переменную name.
// Скопируйте значение из переменной name в admin.
// Выведите на экран значение admin, используя функцию alert (должна показать «Джон»).

// 2.5 Типы данных

// Есть восемь основных типов данных в JavaScript.
// Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:

// Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит,
// что типы данных есть, но переменные не привязаны ни к одному из них.

// Число

// Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой.

// Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

// Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных:
// Infinity, -Infinity и NaN.

// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции
// Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN

// Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

// BigInt

// В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), или меньше, чем -(253-1)
// для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.

// Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:
// const bigInt = 1234567890123456789012345678901234567890n;

// Строка

// В JavaScript существует три типа кавычек.

// Двойные кавычки: "Привет".
// Одинарные кавычки: 'Привет'.
// Обратные кавычки: `Привет`.

// Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}.

// Булевый (логический) тип

// Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).

// Булевые значения также могут быть результатом сравнений:
// let isGreater = 4 > 1;
// alert( isGreater ); // true (результатом сравнения будет "да")

// Значение «null»

// Специальное значение null не относится ни к одному из типов, описанных выше.
// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

// Значение «undefined»

// Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
// Оно означает, что «значение не было присвоено».

// Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

// let age;
// alert(age); // выведет "undefined"

// Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения,
// а undefined – для проверок, была ли переменная назначена.

// Объекты и символы

// Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения
// (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

// Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.

// Оператор typeof

// Оператор typeof возвращает тип аргумента.

// Синтаксис оператора: typeof x.
// Синтаксис функции: typeof(x).

// Math — это встроенный объект, который предоставляет математические операции и константы.

// Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof,
// ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом.
// Это специальное значение с отдельным типом.

//  Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах,
//  где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но typeof
//  обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. Формально это неверно,
//  но может быть удобным на практике.

// Итого
// В JavaScript есть 8 основных типов.

// number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
// bigint для целых чисел произвольной длины.
// string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
// boolean для true/false.
// null для неизвестных значений – отдельный тип, имеющий одно значение null.
// undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
// object для более сложных структур данных.
// symbol для уникальных идентификаторов.
// Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

// Имеет две формы: typeof x или typeof(x).
// Возвращает строку с именем типа. Например, "string".
// Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

// 2.6 Взаимодействие: alert, prompt, confirm

// alert

// небольшое окно с сообщением называется модальным окном. Понятие модальное означает, что пользователь
// не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до
// тех пор, пока взаимодействует с окном. В данном случае – пока не будет нажата кнопка «OK».

// prompt

// Функция prompt принимает два аргумента:
// result = prompt(title, [default]);

// Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

// title
// Текст для отображения в окне.
// default
// Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.

// Квадратные скобки в синтаксисе [...]
// Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

// Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result.
// Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

// confirm

// result = confirm(question);
// Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

// Итого
// Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

// alert
// показывает сообщение.

// prompt
// показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null,
// если была нажата кнопка «Отмена» или Esc с клавиатуры.

// confirm
// показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена.
//  Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
// Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать
// с остальной частью страницы до тех пор, пока окно не будет закрыто.

// На все указанные методы распространяются два ограничения:

// Расположение окон определяется браузером. Обычно окна находятся в центре.
// Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
// Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой
// функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

// 2.7 Преобразование типов

// Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.
// Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

// Строковое преобразование
// value = String(value);

// Численное преобразование

// Численное преобразование происходит в математических функциях и выражениях.
// Например, когда операция деления / применяется не к числу

// let num = Number(str); // становится числом 123

// Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN

// Правила численного преобразования:

// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0,
// иначе из непустой строки «считывается» число. При ошибке результат NaN.

// Примеры:

// alert( Number("   123   ") ); // 123
// alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
// alert( Number(true) );        // 1
// alert( Number(false) );       // 0
// Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.

// Логическое преобразование

// Происходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями),
// но также может быть выполнено явно с помощью функции Boolean(value).

// Правило преобразования:

// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true.

// Например:

// alert( Boolean(1) ); // true
// alert( Boolean(0) ); // false

// alert( Boolean("Привет!") ); // true
// alert( Boolean("") ); // false
// Заметим, что строчка с нулём "0" — это true

// Итого

// Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

// Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value).
// Для примитивных значений работает очевидным образом.

// Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

// Преобразование подчиняется правилам:

// Значение	Становится…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0,
// иначе из непустой строки «считывается» число. При ошибке результат NaN.
// Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).

// Подчиняется правилам:

// Значение	Становится…
// 0, null, undefined, NaN, ""	false
// любое другое значение	true
// Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

// undefined при численном преобразовании становится NaN, не 0.
// "0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.

// 2.8 Базовые операторы, математика

// Многие операторы знакомы нам ещё со школы: сложение +, умножение *, вычитание - и так далее.

// Термины: «унарный», «бинарный», «операнд»

// Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд
//  равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

// Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный

// Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

// Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания
// (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).

// Математика
// Поддерживаются следующие математические операторы:

// Сложение +,
// Вычитание -,
// Умножение *,
// Деление /,
// Взятие остатка от деления %,
// Возведение в степень **.
// Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.

// Сложение строк при помощи бинарного +

// если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
// Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают
// только с числами и всегда преобразуют операнды в числа.

// Приведение к числу, унарный +

// Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.

// Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами.
// Но если операнд не число, унарный плюс преобразует его в число.
// На самом деле это то же самое, что и Number(...), только короче.

// Приоритет операторов

// Инкремент/декремент

// Важно:
// Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.

// Операторы ++ и -- могут быть расположены не только после, но и до переменной.

// Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
// «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.

// Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

// Побитовые операторы

// Поддерживаются следующие побитовые операторы:

// AND(и) ( & )
// OR(или) ( | )
// XOR(побитовое исключающее или) ( ^ )
// NOT(не) ( ~ )
// LEFT SHIFT(левый сдвиг) ( << )
// RIGHT SHIFT(правый сдвиг) ( >> )
// ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

// Оператор «запятая»

// 2.9 Операторы сравнения

// Результат сравнения имеет логический тип

// При использовании математических операторов и других операторов сравнения < > <= >=
// Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Итого
// Операторы сравнения возвращают значения логического типа.
// Строки сравниваются посимвольно в лексикографическом порядке.
// Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
// Значения null и undefined равны == друг другу и не равны любому другому значению.
// Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined.
// Хорошей идеей будет сделать отдельную проверку на null/undefined.

// 2.10 Условное ветвление: if, '?'

// Иногда нам нужно выполнить различные действия в зависимости от условий.

// Для этого мы можем использовать инструкцию if и условный оператор ?, который также называют оператором «вопросительный знак».

// Инструкция «if»
// Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.

// Преобразование к логическому типу
// Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.

// Давайте вспомним правила преобразования типов из главы Преобразование типов:

// Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
// Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).

// Блок «else»
// Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.

// Несколько условий: «else if»
// Иногда, нужно проверить несколько вариантов условия. Для этого используется блок else if.

// Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

// Синтаксис:

// let result = условие ? значение1 : значение2;
// let accessAllowed = (age > 18) ? true : false;

// На заметку:
// В примере выше вы можете избежать использования оператора вопросительного знака ?, т.к. сравнение само по себе уже возвращает true/false:

// // то же самое
// let accessAllowed = age > 18;

// Несколько операторов „?“

// let age = prompt('Возраст?', 18);

// let message = (age < 3) ? 'Здравствуй, малыш!' :
//   (age < 18) ? 'Привет!' :
//   (age < 100) ? 'Здравствуйте!' :
//   'Какой необычный возраст!';

// alert( message );

Нетрадиционное использование „?“
Иногда оператор «вопросительный знак» ? используется в качестве замены if:

let company = prompt('Какая компания создала JavaScript?', '');

(company == 'Netscape') ?
   alert('Верно!') : alert('Неправильно.');
В зависимости от условия company == 'Netscape', будет выполнена либо первая, либо вторая часть после ?.

Здесь мы не присваиваем результат переменной. Вместо этого мы выполняем различный код в зависимости от условия.

2.11 Логические операторы

В JavaScript есть три логических оператора: || (ИЛИ), && (И) и ! (НЕ).
Если значение не логического типа, то оно к нему приводится в целях вычислений.
Например, число 1 будет воспринято как true, а 0 – как false:

Оператор || выполняет следующие действия:

Вычисляет операнды слева направо.
Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
Если все операнды являются ложными (false), возвращает последний из них.

Другими словами, цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.
Вычисление останавливается при достижении первого истинного значения.
этот процесс называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае, 
если первого недостаточно для вычисления всего выражения.

&& (И)

И «&&» находит первое ложное значение

Оператор && выполняет следующие действия:

Вычисляет операнды слева направо.
Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний.
Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

Приоритет оператора && больше, чем у ||

! (НЕ)

Оператор принимает один аргумент и выполняет следующие действия:

Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.
Например:

alert( !true ); // false
alert( !0 ); // true

В частности, двойное НЕ используют для преобразования значений к логическому типу:

alert( !!"non-empty string" ); // true
alert( !!null ); // false
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова 
инвертирует его. В конце мы имеем простое преобразование значения в логическое.

Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:

alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.