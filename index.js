///  Modern JavaScript tutorial  ///

// ВВЕДЕНИЕ

// 1.1 Введение в JavaScript

// Что такое JavaScript?

// Изначально JavaScript был создан, чтобы «сделать веб-страницы живыми».
// Программы на этом языке называются скриптами. Они могут встраиваться в HTML и выполняться автоматически при загрузке веб-страницы.
// Скрипты распространяются и выполняются, как простой текст. Им не нужна специальная подготовка или компиляция для запуска.

// Как работают движки?
// Движки сложны. Но основы понять легко.

// Движок (встроенный, если это браузер) читает («парсит») текст скрипта.
// Затем он преобразует («компилирует») скрипт в машинный язык.
// После этого машинный код запускается и работает достаточно быстро.

// Например, в браузере JavaScript может:

// Добавлять новый HTML-код на страницу, изменять существующее содержимое, модифицировать стили.
// Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.
// Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии AJAX и COMET).
// Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.
// Запоминать данные на стороне клиента («local storage»).

// сильные стороны JavaScript:

// Полная интеграция с HTML/CSS.
// Простые вещи делаются просто.
// Поддерживается всеми основными браузерами и включён по умолчанию.

// 1.2 Справочники и спецификации

// Спецификация ECMA-262
// https://www.ecma-international.org/publications/standards/Ecma-262.htm

// Чтобы почитать о самых последних возможностях, включая те, которые «почти в стандарте»
// (так называемые «stage 3 proposals»), посетите https://github.com/tc39/proposals.

// Справочники

// MDN (Mozilla) JavaScript Reference
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference

// MSDN
// https://docs.microsoft.com/ru-ru/

// Таблицы совместимости

// Посмотреть, какие возможности поддерживаются в разных браузерах и других движках, можно в следующих источниках:

// http://caniuse.com – таблицы с информацией о поддержке по каждой возможности языка. Например, чтобы узнать, какие движки поддерживают современные криптографические функции, посетите: http://caniuse.com/#feat=cryptography.
// https://kangax.github.io/compat-table – таблица с возможностями языка и движками, которые их поддерживают и не поддерживают.

// 1.3 Редакторы кода

// Есть два основных типа редакторов: IDE и «лёгкие» редакторы. Многие используют по одному инструменту каждого типа.

// IDE

// Термином IDE (Integrated Development Environment, «интегрированная среда разработки») называют мощные редакторы с
//  множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а нечто большее.

//  IDE загружает проект (который может состоять из множества файлов), позволяет переключаться между файлами, предлагает автодополнение по коду всего проекта (а не только открытого файла), также она интегрирована с системой контроля версий (например, такой как git), средой для тестирования и другими инструментами на уровне всего проекта.

// Если вы ещё не выбрали себе IDE, присмотритесь к этим:

// Visual Studio Code (бесплатно).
// WebStorm (платно).

// «Лёгкие» редакторы

// «Лёгкие» редакторы менее мощные, чем IDE, но они отличаются скоростью, удобным интерфейсом и простотой.

// Главное отличие между «лёгким» редактором и IDE состоит в том, что IDE работает на уровне целого проекта, поэтому
// она загружает больше данных при запуске, анализирует структуру проекта, если это необходимо, и так далее. Если вы
// работаете только с одним файлом, то гораздо быстрее открыть его в «лёгком» редакторе.

// Следующие варианты заслуживают вашего внимания:

// Atom (кроссплатформенный, бесплатный).
// Sublime Text (кроссплатформенный, условно-бесплатный).
// Notepad++ (Windows, бесплатный).
// Vim и Emacs тоже хороши, если знать, как ими пользоваться.

// 1.4 Консоль разработчика(F12)

// Под сообщением об ошибке находится синий символ >. Он обозначает командную строку, в ней мы можем редактировать
// и запускать JavaScript-команды. Для их запуска нажмите Enter.

// Многострочный ввод
// Обычно при нажатии Enter введённая строка кода сразу выполняется.

// Чтобы перенести строку, нажмите Shift+Enter. Так можно вводить более длинный JS-код.

// Итого

// Инструменты разработчика позволяют нам смотреть ошибки, выполнять команды, проверять значение переменных и ещё много всего полезного.
// В большинстве браузеров, работающих под Windows, инструменты разработчика можно открыть, нажав F12.
// В Chrome для Mac используйте комбинацию Cmd+Opt+J, Safari: Cmd+Opt+C (необходимо предварительное включение «Меню разработчика»).

// ОСНОВЫ JavaScript

// 2.1 Привет, мир!

// Тег «script»
// Программы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега <script>.

// <script>
// alert( 'Привет, мир!' );
// </script>

// Внешние скрипты

// Файл скрипта можно подключить к HTML с помощью атрибута src:

// <script src="/path/to/script.js"></script>

// Здесь /path/to/script.js – это абсолютный путь до скрипта от корня сайта. Также можно указать
// относительный путь от текущей страницы. Например, src="script.js" будет означать, что файл "script.js" находится в текущей папке.

// Можно указать и полный URL-адрес. Например:

// <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>

// Для подключения нескольких скриптов используйте несколько тегов:

// <script src="/js/script1.js"></script>
// <script src="/js/script2.js"></script>

// На заметку:

// Как правило, только простейшие скрипты помещаются в HTML. Более сложные выделяются в отдельные файлы.
// Польза от отдельных файлов в том, что браузер загрузит скрипт отдельно и сможет хранить его в кеше.
// Другие страницы, которые подключают тот же скрипт, смогут брать его из кеша вместо повторной загрузки
// из сети. И таким образом файл будет загружаться с сервера только один раз.
// Это сокращает расход трафика и ускоряет загрузку страниц.

// Если атрибут src установлен, содержимое тега script будет игнорироваться.

// <script src="file.js">
//   alert(1); // содержимое игнорируется, так как есть атрибут src
// </script>

// <script src="file.js"></script>
// <script>
//   alert(1);
// </script>

// Итого
// Для добавления кода JavaScript на страницу используется тег <script>
// Атрибуты type и language необязательны.
// Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>.

// 2.2 Структура кода

// Инструкции
// Инструкции – это синтаксические конструкции и команды, которые выполняют действия.

// alert('Привет, мир!')

// Точка с запятой

// alert('Привет')
// alert('Мир')
// В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.

// В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!

// В некоторых ситуациях новая строка всё же не означает точку с запятой. Например:

// alert(3 +
// 1
// + 2);

// Комментарии

// Однострочные комментарии начинаются с двойной косой черты //.
// Часть строки после // считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.

// Многострочные комментарии начинаются косой чертой со звёздочкой /* и заканчиваются звёздочкой с косой чертой */.

// Используйте горячие клавиши!
// В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+
// / для однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев
// (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.

// Вложенные комментарии не поддерживаются!

// 2.4 Переменные

// JavaScript-приложению обычно нужно работать с информацией. Например:

// Интернет-магазин – информация может включать продаваемые товары и корзину покупок.
// Чат – информация может включать пользователей, сообщения и многое другое.
// Переменные используются для хранения этой информации.

// Переменная – это «именованное хранилище» для данных.

// Приведённая ниже инструкция создаёт (другими словами: объявляет или определяет) переменную с именем «message»:

// let message;

// оператор присваивания =

// Имена переменных
// В JavaScript есть два ограничения, касающиеся имён переменных:

// Имя переменной должно содержать только буквы, цифры или символы $ и _.
// Первый символ не должен быть цифрой.

// Итого
// Мы можем объявить переменные для хранения данных с помощью ключевых слов var, let или const.

// let – это современный способ объявления.
// var – это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое слово "var" на случай, если это всё-таки вам понадобится.
// const – похоже на let, но значение переменной не может изменяться.
// Переменные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.

// Объявите две переменные: admin и name.
// Запишите строку "Джон" в переменную name.
// Скопируйте значение из переменной name в admin.
// Выведите на экран значение admin, используя функцию alert (должна показать «Джон»).

// 2.5 Типы данных

// Есть восемь основных типов данных в JavaScript.
// Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:

// Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит,
// что типы данных есть, но переменные не привязаны ни к одному из них.

// Число

// Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой.

// Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

// Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных:
// Infinity, -Infinity и NaN.

// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции
// Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN

// Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

// BigInt

// В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), или меньше, чем -(253-1)
// для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.

// Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:
// const bigInt = 1234567890123456789012345678901234567890n;

// Строка

// В JavaScript существует три типа кавычек.

// Двойные кавычки: "Привет".
// Одинарные кавычки: 'Привет'.
// Обратные кавычки: `Привет`.

// Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}.

// Булевый (логический) тип

// Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).

// Булевые значения также могут быть результатом сравнений:
// let isGreater = 4 > 1;
// alert( isGreater ); // true (результатом сравнения будет "да")

// Значение «null»

// Специальное значение null не относится ни к одному из типов, описанных выше.
// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

// Значение «undefined»

// Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
// Оно означает, что «значение не было присвоено».

// Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

// let age;
// alert(age); // выведет "undefined"

// Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения,
// а undefined – для проверок, была ли переменная назначена.

// Объекты и символы

// Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения
// (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

// Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.

// Оператор typeof

// Оператор typeof возвращает тип аргумента.

// Синтаксис оператора: typeof x.
// Синтаксис функции: typeof(x).

// Math — это встроенный объект, который предоставляет математические операции и константы.

// Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof,
// ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом.
// Это специальное значение с отдельным типом.

//  Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах,
//  где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но typeof
//  обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. Формально это неверно,
//  но может быть удобным на практике.

// Итого
// В JavaScript есть 8 основных типов.

// number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
// bigint для целых чисел произвольной длины.
// string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
// boolean для true/false.
// null для неизвестных значений – отдельный тип, имеющий одно значение null.
// undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
// object для более сложных структур данных.
// symbol для уникальных идентификаторов.
// Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

// Имеет две формы: typeof x или typeof(x).
// Возвращает строку с именем типа. Например, "string".
// Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

// 2.6 Взаимодействие: alert, prompt, confirm

// alert

// небольшое окно с сообщением называется модальным окном. Понятие модальное означает, что пользователь
// не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до
// тех пор, пока взаимодействует с окном. В данном случае – пока не будет нажата кнопка «OK».

// prompt

// Функция prompt принимает два аргумента:
// result = prompt(title, [default]);

// Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

// title
// Текст для отображения в окне.
// default
// Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.

// Квадратные скобки в синтаксисе [...]
// Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

// Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result.
// Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

// confirm

// result = confirm(question);
// Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

// Итого
// Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

// alert
// показывает сообщение.

// prompt
// показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null,
// если была нажата кнопка «Отмена» или Esc с клавиатуры.

// confirm
// показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена.
//  Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
// Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать
// с остальной частью страницы до тех пор, пока окно не будет закрыто.

// На все указанные методы распространяются два ограничения:

// Расположение окон определяется браузером. Обычно окна находятся в центре.
// Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
// Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой
// функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

// 2.7 Преобразование типов

// Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.
// Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

// Строковое преобразование
// value = String(value);

// Численное преобразование

// Численное преобразование происходит в математических функциях и выражениях.
// Например, когда операция деления / применяется не к числу

// let num = Number(str); // становится числом 123

// Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN

// Правила численного преобразования:

// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0,
// иначе из непустой строки «считывается» число. При ошибке результат NaN.

// Примеры:

// alert( Number("   123   ") ); // 123
// alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
// alert( Number(true) );        // 1
// alert( Number(false) );       // 0
// Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.

// Логическое преобразование

// Происходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями),
// но также может быть выполнено явно с помощью функции Boolean(value).

// Правило преобразования:

// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true.

// Например:

// alert( Boolean(1) ); // true
// alert( Boolean(0) ); // false

// alert( Boolean("Привет!") ); // true
// alert( Boolean("") ); // false
// Заметим, что строчка с нулём "0" — это true

// Итого

// Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

// Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value).
// Для примитивных значений работает очевидным образом.

// Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

// Преобразование подчиняется правилам:

// Значение	Становится…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0,
// иначе из непустой строки «считывается» число. При ошибке результат NaN.
// Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).

// Подчиняется правилам:

// Значение	Становится…
// 0, null, undefined, NaN, ""	false
// любое другое значение	true
// Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

// undefined при численном преобразовании становится NaN, не 0.
// "0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.

// 2.8 Базовые операторы, математика

// Многие операторы знакомы нам ещё со школы: сложение +, умножение *, вычитание - и так далее.

// Термины: «унарный», «бинарный», «операнд»

// Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд
//  равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

// Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный

// Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

// Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания
// (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).

// Математика
// Поддерживаются следующие математические операторы:

// Сложение +,
// Вычитание -,
// Умножение *,
// Деление /,
// Взятие остатка от деления %,
// Возведение в степень **.
// Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.

// Сложение строк при помощи бинарного +

// если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
// Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают
// только с числами и всегда преобразуют операнды в числа.

// Приведение к числу, унарный +

// Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.

// Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами.
// Но если операнд не число, унарный плюс преобразует его в число.
// На самом деле это то же самое, что и Number(...), только короче.

// Приоритет операторов

// Инкремент/декремент

// Важно:
// Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.

// Операторы ++ и -- могут быть расположены не только после, но и до переменной.

// Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
// «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.

// Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

// Побитовые операторы

// Поддерживаются следующие побитовые операторы:

// AND(и) ( & )
// OR(или) ( | )
// XOR(побитовое исключающее или) ( ^ )
// NOT(не) ( ~ )
// LEFT SHIFT(левый сдвиг) ( << )
// RIGHT SHIFT(правый сдвиг) ( >> )
// ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

// Оператор «запятая»

// 2.9 Операторы сравнения

// Результат сравнения имеет логический тип

// При использовании математических операторов и других операторов сравнения < > <= >=
// Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Итого
// Операторы сравнения возвращают значения логического типа.
// Строки сравниваются посимвольно в лексикографическом порядке.
// Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
// Значения null и undefined равны == друг другу и не равны любому другому значению.
// Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined.
// Хорошей идеей будет сделать отдельную проверку на null/undefined.

// 2.10 Условное ветвление: if, '?'

// Иногда нам нужно выполнить различные действия в зависимости от условий.

// Для этого мы можем использовать инструкцию if и условный оператор ?, который также называют оператором «вопросительный знак».

// Инструкция «if»
// Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.

// Преобразование к логическому типу
// Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.

// Давайте вспомним правила преобразования типов из главы Преобразование типов:

// Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
// Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).

// Блок «else»
// Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.

// Несколько условий: «else if»
// Иногда, нужно проверить несколько вариантов условия. Для этого используется блок else if.

// Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

// Синтаксис:

// let result = условие ? значение1 : значение2;
// let accessAllowed = (age > 18) ? true : false;

// На заметку:
// В примере выше вы можете избежать использования оператора вопросительного знака ?, т.к. сравнение само по себе уже возвращает true/false:

// // то же самое
// let accessAllowed = age > 18;

// Несколько операторов „?“

// let age = prompt('Возраст?', 18);

// let message = (age < 3) ? 'Здравствуй, малыш!' :
//   (age < 18) ? 'Привет!' :
//   (age < 100) ? 'Здравствуйте!' :
//   'Какой необычный возраст!';

// alert( message );

// Нетрадиционное использование „?“
// Иногда оператор «вопросительный знак» ? используется в качестве замены if:

// let company = prompt('Какая компания создала JavaScript?', '');

// (company == 'Netscape') ?
//    alert('Верно!') : alert('Неправильно.');
// В зависимости от условия company == 'Netscape', будет выполнена либо первая, либо вторая часть после ?.

// Здесь мы не присваиваем результат переменной. Вместо этого мы выполняем различный код в зависимости от условия.

// 2.11 Логические операторы

// В JavaScript есть три логических оператора: || (ИЛИ), && (И) и ! (НЕ).
// Если значение не логического типа, то оно к нему приводится в целях вычислений.
// Например, число 1 будет воспринято как true, а 0 – как false:

// Оператор || выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
// Если все операнды являются ложными (false), возвращает последний из них.

// Другими словами, цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.
// Вычисление останавливается при достижении первого истинного значения.
// этот процесс называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае,
// если первого недостаточно для вычисления всего выражения.

// && (И)

// И «&&» находит первое ложное значение

// Оператор && выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
// Если все операнды были истинными, возвращается последний.
// Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

// Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

// Приоритет оператора && больше, чем у ||

// ! (НЕ)

// Оператор принимает один аргумент и выполняет следующие действия:

// Сначала приводит аргумент к логическому типу true/false.
// Затем возвращает противоположное значение.
// Например:

// alert( !true ); // false
// alert( !0 ); // true

// В частности, двойное НЕ используют для преобразования значений к логическому типу:

// alert( !!"non-empty string" ); // true
// alert( !!null ); // false
// То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова
// инвертирует его. В конце мы имеем простое преобразование значения в логическое.

// Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:

// alert( Boolean("non-empty string") ); // true
// alert( Boolean(null) ); // false
// Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

// let userName = prompt("Кто там?", '');

// if (userName == 'Админ') {

//   let pass = prompt('Пароль?', '');

//   if (pass == 'Я главный') {
//     alert( 'Здравствуйте!' );
//   } else if (pass == '' || pass == null) {
//     alert( 'Отменено' );
//   } else {
//     alert( 'Неверный пароль' );
//   }

// } else if (userName == '' || userName == null) {
//   alert( 'Отменено' );
// } else {
//   alert( "Я вас не знаю" );
// }

// 2.12 Оператор объединения с null '??'

// Результат выражения a ?? b будет следующим:

// a, если значение a определено,
// b, если значение a не определено.

// Важное различие между ними заключается в том, что:

// || возвращает первое истинное значение.
// ?? возвращает первое определённое значение.

// Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковые,
// т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений,
// то в качестве результата мы получим второй аргумент.

// Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined.
// Ведь именно тогда значение действительно неизвестно/не определено.

// Итого
// Оператор объединения с null ?? — это быстрый способ выбрать первое «определённое» значение из списка.

// Используется для присвоения переменным значений по умолчанию:

// // будет height=100, если переменная height равна null или undefined
// height = height ?? 100;
// Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

// Запрещено использовать вместе с || или && без явно указанных круглых скобок.

// 2.13 Циклы while и for

// Цикл «while»
// Цикл while имеет следующий синтаксис:

// выводит i, пока i < 3:

// let i = 0;
// while (i < 3) { // выводит 0, затем 1, затем 2
//   alert( i );
//   i++;
// }

// Например, while (i) – более краткий вариант while (i != 0):
// Фигурные скобки не требуются для тела цикла из одной строки

// Цикл «do…while»

// Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

// do {
//     // тело цикла
//   } while (condition);

// Например:

// let i = 0;
// do {
//   alert( i );
//   i++;
// } while (i < 3);

// Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз,
// даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.

// Цикл «for»

// for (начало; условие; шаг) {
//     // ... тело цикла ...
//   }

//   for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
//     alert(i);
//   }

//   Рассмотрим конструкцию for подробней:

// часть
// начало	i = 0	Выполняется один раз при входе в цикл
// условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.
// шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
// тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.

// Прерывание цикла: «break»

// Переход к следующей итерации: continue
// Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается,
// а переходит к следующей итерации (если условие все ещё равно true).
// Директива continue позволяет избегать вложенности

// Нельзя использовать break/continue справа от оператора „?“
// Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором ?. В частности, использование таких директив, как break/continue, вызовет ошибку.

// Например, если мы возьмём этот код:

// if (i > 5) {
//   alert(i);
// } else {
//   continue;
// }
// …и перепишем его, используя вопросительный знак:

// (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
// …то будет синтаксическая ошибка.

// Это ещё один повод не использовать оператор вопросительного знака ? вместо if.

// Метки для break/continue

// Метка имеет вид идентификатора с двоеточием перед циклом:
// labelName: for (...) {
//   ...
// }

// Мы рассмотрели 3 вида циклов:

// while – Проверяет условие перед каждой итерацией.
// do..while – Проверяет условие после каждой итерации.
// for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
// Чтобы организовать бесконечный цикл, используют конструкцию while (true). При этом он,
// как и любой другой цикл, может быть прерван директивой break.

// Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.

// Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue
// выйти за пределы текущего цикла, повлиять на выполнение внешнего.

// 2.15 Фунцкии

// Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы.

// Объявление функции
// function showMessage() {
//     alert( 'Всем привет!' );
//   }

//   Вначале идёт ключевое слово function, после него имя функции, затем список параметров в круглых скобках
//   через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.
//   Наша новая функция может быть вызвана по её имени: showMessage().

//   Локальные переменные
// Переменные, объявленные внутри функции, видны только внутри этой функции.

// Внешние переменные
// У функции есть доступ к внешним переменным
// Внешняя переменная используется, только если внутри функции нет такой локальной.
// Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.

// Глобальные переменные
// Переменные, объявленные снаружи всех функций, такие как внешняя переменная userName в вышеприведённом коде – называются глобальными.

// Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).

// Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных.
//  Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

//  Параметры

//  Мы можем передать внутрь функции любую информацию, используя параметры (также называемые аргументами функции).
//  function showMessage(from, text) { // аргументы: from, text
//     alert(from + ': ' + text);
//   }

//   Вот ещё один пример: у нас есть переменная from, и мы передаём её функции. Обратите внимание: функция изменяет значение from,
//   но это изменение не видно снаружи. Функция всегда получает только копию значения

//   function showMessage(from, text) {

//     from = '*' + from + '*'; // немного украсим "from"

//     alert( from + ': ' + text );
//   }

//   let from = "Аня";

//   showMessage(from, "Привет"); // *Аня*: Привет

//   // значение "from" осталось прежним, функция изменила значение локальной переменной
//   alert( from ); // Аня

//   Параметры по умолчанию
// Если параметр не указан, то его значением становится undefined.

// function showMessage(from, text = "текст не добавлен")

// Вычисление параметров по умолчанию
// В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра.

// В примере выше anotherFunction() будет вызываться каждый раз, когда showMessage() вызывается без параметра text

// Возврат значения

// Функция может вернуть результат, который будет передан в вызвавший её код.

// Простейшим примером может служить функция сложения двух чисел:

// function sum(a, b) {
//   return a + b;
// }

// let result = sum(1, 2);
// alert( result ); // 3

// Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места,
// функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной result выше).

// Результат функции с пустым return или без него – undefined
// Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined:

// function doNothing() { /* пусто */ }

// alert( doNothing() === undefined ); // true

// Пустой return аналогичен return undefined:

// function doNothing() {
//   return;
// }

// alert( doNothing() === undefined ); // true

// Никогда не добавляйте перевод строки между return и его значением

// Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и return.
// Или, хотя бы, поставить там открывающую скобку, вот так:

// return (
//   some + long + expression
//   + or +
//   whatever * f(a) + f(b)
//   )

//   Выбор имени функции
// Функция – это действие. Поэтому имя функции обычно является глаголом. Оно должно быть простым, точным и описывать действие функции,
// чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

// Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение.
//  Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

//  Одна функция – одно действие
// Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.

// Итого
// Объявление функции имеет вид:

// function имя(параметры, через, запятую) {
//   /* тело, код функции */
// }

// Передаваемые значения копируются в параметры функции и становятся локальными переменными.
// Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
// Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.
// Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций,
// не пользоваться внешними переменными.

// Функция, которая получает параметры, работает с ними и затем возвращает результат, гораздо понятнее функции,
// вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

// Именование функций:

// Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать,
// что она делает, и что возвращает.
// Функция – это действие, поэтому её имя обычно является глаголом.
// Есть много общепринятых префиксов, таких как: create…, show…, get…, check… и т.д. Пользуйтесь ими как подсказками,
// поясняющими, что делает функция.
// Функции являются основными строительными блоками скриптов.

// 2.17 Функции-стрелки, основы

// «функции-стрелки» или «стрелочные функции» (arrow functions), т.к. выглядит следующим образом:

// let func = (arg1, arg2, ...argN) => expression
// …Такой код создаёт функцию func с аргументами arg1..argN и вычисляет expression с правой стороны с их использованием, возвращая результат.

// Другими словами, это более короткий вариант такой записи:

// let func = function(arg1, arg2, ...argN) {
//   return expression;
// };

// Функции-стрелки могут быть использованы так же, как и Function Expression.

// Например, для динамического создания функции:

// let age = prompt("Сколько Вам лет?", 18);

// let welcome = (age < 18) ?
//   () => alert('Привет') :
//   () => alert("Здравствуйте!");

// welcome(); // теперь всё в порядке

// Функции-стрелки очень удобны для однострочных действий. Они бывают двух типов:

// Без фигурных скобок: (...args) => expression – правая сторона выражение: функция выполняет его и возвращает результат.
// С фигурными скобками: (...args) => { body } – скобки позволяют нам писать многострочные инструкции внутри функции,
// но при этом необходимо указывать директиву return, чтобы вернуть какое-либо значение.

// 2.18 Особенности JavaScript

// Переменные
// Можно объявить при помощи:

// let
// const (константа, т.е. изменению не подлежит)
// var (устаревший способ, подробности позже)
// Имя переменной может включать:

// Буквы и цифры, однако цифра не может быть первым символом.
// Символы $ и _ используются наряду с буквами.
// Иероглифы и символы нелатинского алфавита также допустимы, но обычно не используются.
// Переменные типизируются динамически. В них могут храниться любые значения:

// let x = 5;
// x = "Вася";
// Всего существует 8 типов данных:

// number для целых и вещественных чисел,
// bigint для работы с целыми числами произвольной длины,
// string для строк,
// boolean для логических значений истинности или ложности: true/false,
// null – тип с единственным значением null, т.е. «пустое значение» или «значение не существует»,
// undefined – тип с единственным значением undefined, т.е. «значение не задано»,
// object и symbol – сложные структуры данных и уникальные идентификаторы; их мы ещё не изучили.
// Оператор typeof возвращает тип значения переменной, с двумя исключениями:

// typeof null == "object" // ошибка в языке
// typeof function(){} == "function" // именно для функций

// Взаимодействие с посетителем
// В качестве рабочей среды мы используем браузер, так что простейшими функциями взаимодействия с посетителем являются:

// prompt(question, [default])
// Задаёт вопрос question и возвращает то, что ввёл посетитель, либо null, если посетитель нажал на кнопку «Отмена».
// confirm(question)
// Задаёт вопрос question и предлагает выбрать «ОК» или «Отмена». Выбор возвращается в формате true/false.
// alert(message)
// Выводит сообщение message.
// Все эти функции показывают модальные окна, они останавливают выполнение кода и не позволяют посетителю взаимодействовать со страницей,
// пока не будет дан ответ на вопрос.

// Операторы
// JavaScript поддерживает следующие операторы:

// Арифметические
// Простые * + - /, а также деление по модулю % и возведение в степень **.

// Бинарный плюс + объединяет строки. А если одним из операндов является строка, то второй тоже будет конвертирован в строку:

// alert( '1' + 2 ); // '12', строка
// alert( 1 + '2' ); // '12', строка
// Операторы присваивания
// Простые a = b и составные a *= 2.

// Битовые операции
// Битовые операторы работают с 32-битными целыми числами на самом низком, побитовом уровне. Подробнее об их
// использовании можно прочитать на ресурсе MDN и в разделе Побитовые операторы.

// Условный оператор
// Единственный оператор с тремя параметрами: cond ? resultA : resultB. Если условие cond истинно, возвращается resultA, иначе – resultB.

// Логические операторы
// Логические И &&, ИЛИ || используют так называемое «ленивое вычисление» и возвращают значение, на котором оно остановилось
// (не обязательно true или false). Логическое НЕ ! конвертирует операнд в логический тип и возвращает инвертированное значение.

// Сравнение
// Проверка на равенство == значений разных типов конвертирует их в число (за исключением null и undefined, которые
//     могут равняться только друг другу), так что примеры ниже равны:

// alert( 0 == false ); // true
// alert( 0 == '' ); // true
// Другие операторы сравнения тоже конвертируют значения разных типов в числовой тип.

// Оператор строгого равенства === не выполняет конвертирования: разные типы для него всегда означают разные значения.

// Значения null и undefined особенные: они равны == только друг другу, но не равны ничему ещё.

// Операторы сравнения больше/меньше сравнивают строки посимвольно, остальные типы конвертируются в число.

// Циклы
// Мы изучили три вида циклов:

// // 1
// while (condition) {
//   ...
// }

// // 2
// do {
//   ...
// } while (condition);

// // 3
// for(let i = 0; i < 10; i++) {
//   ...
// }
// Переменная, объявленная в цикле for(let...), видна только внутри цикла. Но мы также можем опустить let и переиспользовать существующую переменную.

// Директивы break/continue позволяют выйти из цикла/текущей итерации. Используйте метки для выхода из вложенных циклов.
